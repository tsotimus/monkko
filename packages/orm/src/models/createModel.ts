import type { SchemaDefinition } from "../schemas/defineSchema";
import type { MonkkoClient } from "../connections/createConnection";
import type { Filter, Document, UpdateFilter, WithId } from "mongodb";
import type { Model, QueryBuilder, SingleQueryBuilder } from "./types";

// Type for document creation - excludes _id which is auto-generated by MongoDB
type CreateDocument<Doc> = Omit<Doc, "_id">;

import {
  QueryBuilderImpl,
  SingleQueryBuilderImpl,
  registerSchema,
} from "./query-builder";

export function createModel<
  Doc extends Document,
  S extends SchemaDefinition = SchemaDefinition,
>(schema: S, monkkoClient: MonkkoClient): Model<Doc> {
  const coll = monkkoClient.client.db(schema.db).collection<Doc>(schema.collection);

  // Register the schema for populate functionality
  registerSchema(schema);

  const toJSON = (doc: WithId<Doc>) => {
    return JSON.parse(JSON.stringify(doc));
  };

  return {
    find(filter: Filter<Doc> = {}): QueryBuilder<Doc> {
      return new QueryBuilderImpl<Doc>(
        coll,
        schema,
        monkkoClient,
        filter,
        toJSON,
      );
    },

    findOne(filter: Filter<Doc>): SingleQueryBuilder<Doc> {
      return new SingleQueryBuilderImpl<Doc>(
        coll,
        schema,
        monkkoClient,
        filter,
        toJSON,
      );
    },

    update(filter: Filter<Doc>, update: UpdateFilter<Doc>) {
      // Note: Timestamp functionality is currently limited by MongoDB's strict TypeScript definitions
      // The user's Doc type should include createdAt/updatedAt fields when timestamps are enabled
      // but MongoDB's UpdateFilter type doesn't recognize dynamically added fields

      // For now, we disable timestamps in update operations to maintain type safety
      // TODO: Implement proper timestamp support when MongoDB's types are more flexible
      return coll.updateOne(filter, update);
    },

    create(doc: CreateDocument<Doc>) {
      // Apply field transformations (e.g., convert strings to ObjectIds for objectId fields)
      const transformedDoc = { ...doc } as Record<string, unknown>;

      for (const [fieldName, fieldDef] of Object.entries(schema.fields)) {
        if (fieldDef.transform && transformedDoc[fieldName] !== undefined) {
          const value = transformedDoc[fieldName];
          // Apply transform if value is a string (as expected by transform function)
          if (typeof value === 'string') {
            transformedDoc[fieldName] = fieldDef.transform(value);
          }
        }
      }

      // Use untyped collection to avoid type assertion issues
      const untypedColl = monkkoClient.client.db(schema.db).collection(schema.collection);
      return untypedColl.insertOne(transformedDoc);
    },

    delete(filter: Filter<Doc>) {
      return coll.deleteOne(filter);
    },

    toJSON,
  };
}