import type {
  WithId,
  Filter,
  UpdateFilter,
  InsertOneResult,
  UpdateResult,
  DeleteResult,
  ObjectId,
} from "mongodb";

/**
 * Flattens a complex type into a simpler object type for better readability in tooltips.
 */
export type Prettify<T> = {
  [K in keyof T]: T[K];
} & {};

/**
 * Type for document creation - excludes _id which is auto-generated by MongoDB
 */
type CreateDocument<Doc> = Omit<Doc, "_id">;

/**
 * Represents the options that can be passed to the populate method.
 */
export interface PopulateOptions {
  strategy?: "multiple" | "aggregation";
}

/**
 * Utility type to replace a field's type in a document.
 * It correctly handles optional properties.
 *
 * @template Doc The base document type.
 * @template K The key of the field to replace.
 * @template T The new type for the field.
 */
export type Populate<Doc, K extends keyof Doc, T> = Omit<Doc, K> & {
  [P in K]: Doc[P] extends readonly unknown[]
    ? T[] | Extract<Doc[P], undefined | null>
    : T | Extract<Doc[P], undefined | null>;
};

// QueryBuilder that's directly awaitable and supports type-safe populate
export interface QueryBuilder<Doc> extends PromiseLike<WithId<Doc>[]> {
  populate<T, K extends keyof Doc>(
    field: K,
    options?: PopulateOptions,
  ): QueryBuilder<Prettify<Populate<Doc, K, T>>>;

  // Make it thenable (awaitable)
  then<TResult1 = WithId<Doc>[], TResult2 = never>(
    onfulfilled?:
      | ((value: WithId<Doc>[]) => TResult1 | PromiseLike<TResult1>)
      | undefined
      | null,
    onrejected?:
      | ((reason: unknown) => TResult2 | PromiseLike<TResult2>)
      | undefined
      | null,
  ): PromiseLike<TResult1 | TResult2>;
}

export interface SingleQueryBuilder<Doc>
  extends PromiseLike<WithId<Doc> | null> {
  populate<T, K extends keyof Doc>(
    field: K,
    options?: PopulateOptions,
  ): SingleQueryBuilder<Prettify<Populate<Doc, K, T>>>;

  // Make it thenable (awaitable)
  then<TResult1 = WithId<Doc> | null, TResult2 = never>(
    onfulfilled?:
      | ((value: WithId<Doc> | null) => TResult1 | PromiseLike<TResult1>)
      | undefined
      | null,
    onrejected?:
      | ((reason: unknown) => TResult2 | PromiseLike<TResult2>)
      | undefined
      | null,
  ): PromiseLike<TResult1 | TResult2>;
}

/**
 * Serializes a document type for JSON transport.
 * It converts types like ObjectId and Date to strings.
 */
type Primitives = string | number | boolean | null | undefined;

export type JSONSerialized<T> = T extends Primitives
  ? T
  : T extends ObjectId
  ? string
  : T extends Date
  ? string
  : T extends (infer U)[]
  ? JSONSerialized<U>[]
  : T extends ReadonlyArray<infer U>
  ? ReadonlyArray<JSONSerialized<U>>
  : T extends object
  ? { [K in keyof T]: JSONSerialized<T[K]> }
  : T;

export interface Model<Doc> {
  find(filter?: Filter<Doc>): QueryBuilder<Doc>;
  findOne(filter: Filter<Doc>): SingleQueryBuilder<Doc>;
  create(doc: CreateDocument<Doc>): Promise<InsertOneResult<Doc>>;
  update(filter: Filter<Doc>, update: UpdateFilter<Doc>): Promise<UpdateResult>;
  delete(filter: Filter<Doc>): Promise<DeleteResult>;
  toJSON(doc: WithId<Doc>): Prettify<JSONSerialized<WithId<Doc>>>;
} 